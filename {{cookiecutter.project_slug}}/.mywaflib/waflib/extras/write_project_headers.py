# encoding: utf-8
"""Functions for writing project paths and potentially other
header files for various languages.

"""

import re
from waflib import Task, TaskGen, Errors, Node


PROJECT_PATHS_PYTHON_DOCSTRING_IMPORTS = '''"""Define a dictionary *project_paths* with path
definitions for the entire project.

This module is automatically generated by Waf, never change it!

If paths need adjustment, change them in the root wscript file.\n\n"""

import os
import re
\n\n'''


PROJECT_PATHS_PYTHON_JOIN_FUNCTION = '''\n\ndef project_paths_join(key, *args):
    """Given input of a *key* in the *project_paths* dictionary and a number
    of path arguments *args*, return the joined path constructed by:

    .. code-block:: python

            os.path.join(project_paths[key], *args)

    """

    return os.path.join(project_paths[key], *args)
'''


PROJECT_PATHS_PYTHON_JOIN_LATEX_FUNCTION = r'''

def project_paths_join_latex(key, *args):
    """Given input of a *key* in the *project_paths* dictionary and a number
    of path arguments *args*, return the joined path constructed by::

            os.path.join(project_paths[key], *args)

    and backslashes replaced by forward slashes.

    """

    p = project_paths_join(key, *args)
    p = p.replace('\\', '/')
    p = re.sub('/+', '/', p)

    return p
'''


PROJECT_PATHS_MATLAB_PREAMBLE = '''function[path] = project_paths(key,arg)
%Paths script for Matlab:
%Use command project_paths(key,arg) to obtain the absolute path to the
%directory *key* refers to, with the string in *arg* appended.
%
%For example:
%project_paths('OUT_TABLES','table1.tex') returns your equivalent of
%D:\\workspace\\project\\trunk\\bld\\out\\tables\\table1.tex
%
%project_paths('OUT_ANALYSIS','logs\\reg.log') returns your equivalent of
%D:\\workspace\\project\\trunk\\bld\\out\\analysis\\logs\\reg.log
%
%Note: *arg* is optional.
%
%File is created by waf. Do not change paths here, but in root wscript!

'''


PROJECT_PATHS_MATLAB_END = '''
%define arg if not given
if ~exist('arg','var')
  arg='';
end

path=[getfield(projectpaths, key) '/' arg];
'''


PROJECT_PATHS_R_COMMENT = '''#
# Header with path definitions for entire project.
#
# Automatically generated by Waf, do not change!
#
# If paths need adjustment, perform those in the root wscript file.
#\n\n\n'''


PROJECT_PATHS_PERL_COMMENT = '''#!/usr/bin/perl
# Header with path definitions for entire project.
#
# Automatically generated by Waf, do not change!
#
# If paths need adjustment, perform those in the root wscript file.
#\n\n\n

package project_paths;

use strict;
use warnings;
use Exporter 'import';
our @EXPORT_OK = qw(%project_paths);

our %project_paths = ();
'''


PROJECT_PATHS_STATA_COMMENT = '''//
// Header with path definitions for entire project.
//
// Automatically generated by Waf, do not change!
//
// If paths need adjustment, perform those in the root wscript file.
//
// Note that the paths are added to the top of the ado-path.
//\n\n\n'''


class WriteProjectPathsPython(Task.Task):

    r"""Autogenerate a header with paths for inclusion in Python scripts.

    For this to work, the ``PROJECT_PATHS`` dictionary must be set as an
    environmental variable of the context in the top-level wscript -- it will
    be copied to a dictionary ``project_paths``.

    **Example**::

        PROJECT_PATHS['OUT_FINAL'] = 'bld/out/final'

    leads to::

        project_paths['OUT_FINAL'] = "/abs/path/to/your_project/bld/out/final"

    or::

        project_paths['OUT_FINAL'] = "C:\\your_project\\bld\\out\\final"

    in the module ``project_paths.py``. Assuming that the root directory of
    the project is on your ``PYTHONPATH`` and this script is called from
    ``src/library/python``, you can import the project_paths dictionary using::

        from bld.src.library.python.project_paths import project_paths

    There also is a convenience funtion joining project paths and any
    arguments::

        from bld.src.library.python.project_paths import project_paths_join

    allows you to write:

        out_file = project_paths_join('OUT_FINAL', 'baseline', 'figure.eps')

    """

    def run(self):
        with open(self.outputs[0].abspath(), 'w') as out_file:
            out_file.write(PROJECT_PATHS_PYTHON_DOCSTRING_IMPORTS)
            out_file.write('project_paths = {}\n')
            for name in sorted(self.env.PROJECT_PATHS.keys()):
                val = self.env.PROJECT_PATHS[name]
                if isinstance(val, Node.Node):
                    out_file.write("project_paths['{n}'] = r'{p}'\n".format(
                        n=name,
                        p=val.abspath())
                    )
                else:
                    pass
            # Convenience function
            out_file.write(PROJECT_PATHS_PYTHON_JOIN_FUNCTION)
            out_file.write(PROJECT_PATHS_PYTHON_JOIN_LATEX_FUNCTION)


class WriteProjectPathsMatlab(Task.Task):

    r"""Autogenerate a function with paths for inclusion in Matlab scripts.

    """

    def run(self):
        with open(self.outputs[0].abspath(), 'w')as out_file:
            out_file.write(PROJECT_PATHS_MATLAB_PREAMBLE)
            for name in sorted(self.env.PROJECT_PATHS.keys()):
                val = self.env.PROJECT_PATHS[name]
                if isinstance(val, Node.Node):
                    out_file.write("projectpaths.{n} = '{p}';\n".format(
                        n=name,
                        p=val.abspath())
                    )
                else:
                    pass
            out_file.write(PROJECT_PATHS_MATLAB_END)


class WriteProjectPathsR(Task.Task):

    r"""Autogenerate a header with paths for inclusion in R scripts.

    For this to work, the ``PROJECT_PATHS`` dictionary must be set as an
    environmental variable of the context in the top-level wscript -- it will
    be copied to a dictionary ``project_paths``.

    **Example**::

        PROJECT_PATHS['OUT_FINAL'] = 'bld/out/final'

    leads to::

        PATH_OUT_FINAL <<- '/path/to/your_project/bld/out/final'

    or::

        PATH_OUT_FINAL <<- 'C:\your_project\bld\out\final'

    in the module ``project_paths.r``. Assuming that this task is called
    from a directory ``src/library/R``, you can import the project paths
    using::

        source("src/library/R/project_paths.R")

    """

    def run(self):
        with open(self.outputs[0].abspath(), 'w') as out_file:
            out_file.write(PROJECT_PATHS_R_COMMENT)
            for name in sorted(self.env.PROJECT_PATHS.keys()):
                val = self.env.PROJECT_PATHS[name]
                if isinstance(val, Node.Node):
                    out_file.write("PATH_{n} <<- '{p}'\n".format(
                        n=name,
                        p=val.abspath().replace('\\', '/'))
                    )
                else:
                    pass


class WriteProjectPathsPerl(Task.Task):

    r"""Autogenerate a header with paths for inclusion in Perl scripts.

    For this to work, the ``PROJECT_PATHS`` dictionary must be set as an
    environmental variable of the context in the top-level wscript -- it will
    be copied to a hash ``project_paths``.

    **Example**::

        PROJECT_PATHS['OUT_FINAL'] = 'bld/out/final'

    leads to::

        $project_paths{'OUT_FINAL'} = '/path/to/your_project/bld/out/final';

    or::

        $project_paths{'PATH_OUT_FINAL'} = 'C:\your_project\bld\out\final';

    in the module ``project_paths.pm``. Assuming that this task is called
    from a directory ``src/data_management/``, you can import the project paths
    using::

        use lib 'src/data_management/';
        use project_paths qw(%project_paths);

    """

    def run(self):
        with open(self.outputs[0].abspath(), 'w')as out_file:
            out_file.write(PROJECT_PATHS_PERL_COMMENT)
            for name in sorted(self.env.PROJECT_PATHS.keys()):
                val = self.env.PROJECT_PATHS[name]
                if isinstance(val, Node.Node):
                    out_file.write(
                        "$project_paths{{'{n}'}} = '{p}';\n".format(
                            n=name,
                            p=val.abspath().replace('\\', '/')
                        )
                    )
                else:
                    pass


class WriteProjectPathsStata(Task.Task):

    r"""Autogenerate a header with paths for inclusion in Stata do-files.

    For this to work, the ``PROJECT_PATHS`` dictionary must be set as an
    environmental variable of the build context in the top-level wscript --
    it will be copied to a dictionary ``project_paths``.

    **Example**::

        PROJECT_PATHS['OUT_FINAL'] = 'out/final'

    leads to:

    .. code-block:: none

        global PATH_OUT_FINAL = "/path/to/your_project/bld/out/final"

    or:

    .. code-block:: none

        global PATH_OUT_FINAL = "C:\your_project\out\final"

    in the file ``project_paths.do``. Ado-paths found in the
    ``PROJECT_PATHS['ADO']`` dictionary get a special treatment -- if there are
    keys ``PERSONAL`` or ``PLUS``, the respective system directories will be
    set to their values. Other entries will be prepended to Stata's ado search
    path.

    The file ``project_paths.do`` usually lives in the project's library
    (build) directory. You can then put the lines:

    .. code-block:: none

        include path/to/library/stata/project_paths

    in your Stata do-file and reference the path defined above by writing, for
    example:

    .. code-block:: none

        log using "${PATH_OUT_FINAL}/log/graph_main_results"

    """

    def _write_ado_paths(self, ado_paths, out_file):
        for name, val in ado_paths.items():
            if re.match('PERSONAL|PLUS', name):
                out_file.write('sysdir set {} "{}/"\n'.format(
                    name,
                    val.abspath())
                )
            else:
                out_file.write('adopath ++ "{}/"\n'.format(val.abspath()))
                out_file.write('adopath ++ "{}/"\n'.format(
                    val.get_bld().abspath())
                )
        out_file.write('\n')

    def run(self):
        with open(self.outputs[0].abspath(), 'w') as out_file:
            out_file.write(PROJECT_PATHS_STATA_COMMENT)
            for name in sorted(self.env.PROJECT_PATHS.keys()):
                val = self.env.PROJECT_PATHS[name]
                if isinstance(val, Node.Node):
                    out_file.write(
                        'global PATH_{n} "{p}/"\n'.format(
                            n=name,
                            p=val.abspath()
                        )
                    )
                elif name == 'ADO' and isinstance(val, dict):
                    self._write_ado_paths(val, out_file)


@TaskGen.feature('write_project_paths')
@TaskGen.before_method('process_source')
def apply_write_project_paths(tsk_g):
    """Task generator, customising the options etc. to output the project
    paths header file in the correct language.

    The function is passed a waflib.TaskGen.task_gen object.

    """

    # Get target nodes.
    tgt_nodes = [
        tsk_g.path.find_or_declare(t) for t in tsk_g.to_list(tsk_g.target)
    ]
    # Set top-level wscript as the only dependency (where paths are defined).
    src_node = tsk_g.bld.srcnode.find_resource('wscript')
    # Parse the nodes to get the correct type of output.
    for tgt_node in tgt_nodes:
        if tgt_node.name.endswith('.py'):
            task_str = 'WriteProjectPathsPython'
        elif tgt_node.name.endswith('.m'):
            task_str = 'WriteProjectPathsMatlab'
        elif tgt_node.name.lower().endswith('.r'):
            task_str = 'WriteProjectPathsR'
        elif tgt_node.name.endswith('.pm'):
            task_str = 'WriteProjectPathsPerl'
        elif tgt_node.name.endswith('.do'):
            task_str = 'WriteProjectPathsStata'
        else:
            raise Errors.WafError(
                'Unknown file type of target {}'.format(tgt_node.name)
            )
        # Create the task.
        tsk_g.create_task(task_str, src=src_node, tgt=tgt_node)

    # Bypass the execution of process_source by setting the source to an empty
    # list
    tsk_g.source = []
